//подключение библиотек
#include <stdio.h> //для printf() для ввода и вывода
#include <stdlib.h> // Для rand() для использования рандома, генерации случайных чисел
#include <time.h> // для time() используется для начального значения генератора случайных чисел
typedef struct {//typedef: Это ключевое слово используется для создания нового типа данных на основе существующего типа.
//struct: Это ключевое слово указывает, которое определяет структуру — пользовательский тип данных, который может содержать несколько переменных различных типов.
//проще, помогает каждый раз не писать переменные ,повторять одно и то же
    double real; //реальная, double- тип данных с плавающей запятой, будет точнее float
    double imag; //мнимая
} Array;//Это имя нового типа данных, который мы создали с помощью typedef. мы можем объявлять переменные этого типа, используя имя Array,что существенно упрощает написание кода
// generateRandom-имя Функции,где будет генерация случайных комплексных чисел
Array generateRandomArray() {
    Array a;
    //(double)-более точное деление, (от 0 до 100)делиться на 10,то есть в диапазоне от 0.00 до 9.99
    a.real = (double)(rand() % 100) / 10.0; //от 0,00 до 9,99 Генерация действительной части
    a.imag = (double)(rand() % 100) / 10.0; //от 0,00 до 9,99 Генерация мнимой части
    return a; // возвращает структуру в Array
}
// Функция для сложения двух комплексных чисел(массивы)
Array addArray(Array a, Array b) {
    Array result;
    result.real = a.real + b.real;   // Сложение действительных частей
    result.imag = a.imag + b.imag;   // Сложение мнимых частей
    return result;//рtезультат функции мы будем хранить в result
}
int main() {
    srand(time(0)); // Инициализация генератора случайных чисел начальным числом.
    //без неё каждый раз будут появляться одни и те же одинаковые числа
    int sizeA, sizeB; //создаем массив по размерам ,который написал пользователь
    int result;
    printf("Введите размер массива A: ");
    result= scanf("%d", &sizeA);//ввод данных пользователем
    if (result != 1 || sizeA <=0){//проверка
        printf("Вы ввели число неверно");
        return 1;
    }
    printf("Введите размер массива B: ");
    result=scanf("%d", &sizeB);//ввод даннных пльзователем
    if (result != 1 || sizeA <=0){//проверка
        printf("Вы ввели число неверно");
        return 1;
    }//динамическая память
    Array *A = malloc(sizeA * sizeof(Array)); //malloc выделяет память для массива чисел,Выдели память для массиваA,для всех элементов
    Array *B = malloc(sizeB * sizeof(Array)); //sizeB * sizeof(Array), где sizeB — количество элементов.
    Array *C = malloc(sizeA * sizeof(Array)); // Размер C равен размеру A
    //Если malloc не смог выделить память, он вернет NULL 
    //Динамический массив, с помощью него можно удобно менять размер массива в любое время
    //Если malloc не смог выделить память, он вернет NULL 
    //Динамический массив, с помощью него можно удобно менять размер массива в любое время
    if (A == NULL || B == NULL || C == NULL) { //NULL специальное зарезервированное слово ,если (A равен NULL или B равен NULL или C равен NULL)
        printf("Ошибка выделения памяти\n");//пишем ошибку если условие верно, отсутствует выделенная память
        return 1; // Завершение программы в случае ошибки
    }

    // Заполнение массивов A и B случайными числами
    for (int i = 0; i < sizeA; i++) {//создаем цикл,где переменная i=0 -счётчик,
    //i < sizeA условие,пока size A будет меньше i,он выполнит столько раз сколько в size A,i++ увеличивает значение счётчика на один после каждой итерации
        A[i] = generateRandomArray();//генерации случайных данных в массив A
        //обращение к массиву A[i],где i элемент массива,функции generateRandomArray присваивает значение массиву a[i]
    }
    for (int i = 0; i < sizeB; i++) {//аналогично
        B[i] = generateRandomArray();//генерации случайных данных в массив B
    }

    // Сложение комплексных чисел A и B в массив C
    for (int i = 0; i < sizeA; i++) {//делаем счётчик i, условие:если i будет меньше sizeA, то счётчик +1
        C[i] = addArray(A[i], (i < sizeB ? B[i] : (Array){0, 0})); // Сложение элементов A[i] и B[i] в массив С или 0
    }

    // Поиск максимальной реальной части в массиве A
    double maxReal = A[0].real;// переменная  максимальной реальной назначаем  первым элементом массива A
    for (int i = 1; i < sizeA; i++) {// i=1 Начинаем с второго элемента, так как первый уже определён
        if (A[i].real > maxReal) {// Сравнение текущей реальной части с максимальной
            maxReal = A[i].real;//если условие ввыполнено,то максимальная часть равна реальному массиву A
        }
    }
    printf("Максимальная реальная часть в массиве A: %.2f\n", maxReal);

    // Подсчет количества мнимых частей < 0 в массиве B
    int count = 0;//счётчик
    for (int i = 0; i < sizeB; i++) {// устанавливаем счётчик i, если i < массива sizeB, то к счётчику +1
        if (B[i].imag < 0) {// если мнимая часть массива B меньше 0
            count++;//то к счётчику прибавляем 1 если условие выполняется
        }
    }
    printf("Количество мнимых частей < 0 в массиве B: %d\n", count);
    // Вычисление среднего арифметического среди всех элементов массива C
    double sumReal = 0, sumImag = 0; //переменные с плавающей точкой
    for (int i = 0; i < sizeA; i++) {// устанавливаем счётчик i ,если i < size A, то к счётчику +1
        sumReal += C[i].real;// Суммируем реальные части элементов массива C
        sumImag += C[i].imag;// Суммируем мнимые части элементов массива C
    }
    double sum = (sumReal + sumImag) / (sizeA * 2); // Делим сумму двух массивов на 2(находим среднее арифметическое для обеих частей ), так как 2 компоненты у каждого комплексного числа
    printf("Среднее арифметическое среди всех элементов массива C: %.2f\n", sum);

    // Освобождение памяти,если его не освобождать,то программа будет требовать всё больше и больше памяти 
    //если память не нужна
    free(A);
    free(B);
    free(C);
    //Хорошая практика
    A=NULL;
    B=NULL;
    C=NULL;
    return 0;//завершение программы, это не обязательно, т.к. программа сама может записать return 0
}
